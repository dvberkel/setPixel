#+title setPixel
#+author Daan van Berkel
#+email daan.v.berkel.1980+setpixel@gmail.com

* If All You Got Is =setPixel=

This document is an exploration into graphics algorithms starting
with the primitive =setPixel=.

* Setting the stage

We would like to explore various graphics algorithms, but we do not
want to do that in isolation. It would be great to see how our
algorithms play out. Therefore we our going creating a stage.

#+name: dream-code.setting-stage
#+begin_src js :exports code :tangle no
var stage = new Stage(640, 480);
stage.appendTo(document.getElementById('container'));

stage.setPixel(0,0);
#+end_src

The above code is how we would want to create a new stage and set a
pixel.

** Making dreams come true

The code above is dream code. It does not exist as of yet. So let's
get started and make our dreams come true.

Because we want our code to be well tested we are going to set up a
specification for our stage.

We first make sure that =Stage= exists. It is a helpfull indicator
when things go wrong.

#+name: spec.stage.exists
#+begin_src js :exports code :tangle no
it('must exist', function(){
    expect(Stage).toBeDefined();
});
#+end_src

We also want to make sure that =Stage= is a constructor.

#+name: spec.stage.is_constructor
#+begin_src js :exports code :tangle no
it('must be an constructor', function(){
    expect(typeof Stage).toBe('function');
});
#+end_src

This can be realized in the following way.

#+name: stage.constructor
#+begin_src js :exports code :tangle no
  var Stage = function(width, height){
      this.width = width;
      this.heigth = height;
  }
#+end_src

That leaves the methods =appendTo= and =setPixel=. Let's first look
into the =appendTo= method

We want the =appendTo= method to create a =canvas= element in the dom
element that is passed as a parameter. Lets make a specification.

#+name: spec.stage.appendTo.creates_canvas
#+begin_src js :exports code :tangle no
  it('must create a canvas in the container', function(){
      var stage = new Stage(640, 480);

      stage.appendTo(container);

      expect(container.getElementsByTagName('canvas').length).toBe(1);
  });
#+end_src

it uses a =container= that is created before each test.

#+name: spec.stage.appendTo.setup_teardown
#+begin_src js :exports code :tangle no
  var container;
  beforeEach(function(){
      container = document.createElement('div');
  });
#+end_src

We now need to provide an implementation for that specification.

We first need to create a =canvas= and add it to the =container=.

#+name: stage.appendTo.create_canvas
#+begin_src js :exports code :tangle no
  var canvas = document.createElement('canvas');
  container.appendChild(canvas);
#+end_src

Next we want to save the =context= of the =canvas= we just created
and store if for when we need to draw on it. Because the same stage
could be added to various different containers we store the contexts
in a array.

#+name: stage.appendTo.store_context
#+begin_src js :exports code :tangle no
  if (!this.contexts) {
      this.contexts = [];
  }
  this.contexts.push(canvas.getContext('2d'));

#+end_src

#+name: stage.appendTo
#+begin_src js :exports code :tangle no :noweb yes
  Stage.prototype.appendTo = function(container){
      <<stage.appendTo.create_canvas>>
      <<stage.appendTo.store_context>>
  }
#+end_src

To put it all together we wrap it around an immediatly evaluated
anonymous function to prevent global namespace pollution.

#+name: stage
#+begin_src js :exports code :tangle js/Stage.js :mkdirp :noweb yes
  (function($){
      <<stage.constructor>>

      <<stage.appendTo>>

      $.Stage = Stage;
  })(window);
#+end_src

In case you are wondering the entire specification looks like

#+begin_src js :exports code :tangle spec/StageSpec.js :mkdirp :noweb yes
  describe('Stage', function(){
      <<spec.stage.exists>>
      <<spec.stage.is_constructor>>

      describe('appendTo', function(){
          <<spec.stage.appendTo.setup_teardown>>
          <<spec.stage.appendTo.creates_canvas>>
      });
  });
#+end_src


* Appendix
** Bower

We want to use [[http://bower.io/][bower]] to manage our external dependencies. But because
this is a self contained org-mode document. we have to generated the
=bower.json= file.

#+begin_src json :exports code :tangle bower.json :padline no
{
  "name": "setPixel",
  "version": "0.0.0",
  "homepage": "https://github.com/dvberkel/setPixel",
  "authors": [
    "Daan van Berkel <daan.v.berkel.1980@gmail.com>"
  ],
  "description": "an exploration into graphics algorithms starting from the primitive setPixel",
  "main": "setPixel.html",
  "keywords": [
    "setPixel"
  ],
  "license": "MIT",
  "private": true,
  "ignore": [
    "**/.*",
    "node_modules",
    "bower_components",
    "test",
    "tests"
  ],
  "devDependencies": {
    "jasmine": "~2.0.1"
  }
}
#+end_src

After tangling the document one can run the install command.

#+begin_src sh :tangle no :exports code :results silent
bower install
#+end_src

** Test Suite

We are using [[http://jasmine.github.io/2.0/introduction.html][Jasmine]] to test our code. The exported html document
should run the test suit. We therefor include the Jasmine runner in
our document.

#+begin_html
<link rel="stylesheet" type="text/css" href="bower_components/jasmine/lib/jasmine-core/jasmine.css">

<script type="text/javascript" src="bower_components/jasmine/lib/jasmine-core/jasmine.js"></script>
<script type="text/javascript" src="bower_components/jasmine/lib/jasmine-core/jasmine-html.js"></script>
<script type="text/javascript" src="bower_components/jasmine/lib/jasmine-core/boot.js"></script>

<!-- include source files here... -->
<script type="text/javascript" src="js/Stage.js"></script>

<!-- include spec files here... -->
<script type="text/javascript" src="spec/SetupSpec.js"></script>
<script type="text/javascript" src="spec/StageSpec.js"></script>
#+end_html

We also create a =SetupSpec.js= to make sure this works correctly.

#+begin_src js :exports code :tangle spec/SetupSpec.js :mkdirp yes
  describe('Jasmine Project', function(){
      it('should run specification', function(){
          expect(true).toBeTruthy();
      });
  });
#+end_src
